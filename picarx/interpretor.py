import numpy as np
import cv2
import time
import logging
from logdecorator import log_on_start , log_on_end , log_on_error

logging_format = "%(asctime)s: %(message)s"
logging.basicConfig(format=logging_format, level=logging.INFO, datefmt ="%H:%M:%S")
# logging.getLogger().setLevel(logging.DEBUG)

class Interpretor(object):
    def __init__(self, 
                sensitivity = 0.5,
                polarity = 1):
        ''' inputs: sensitivity (???), polarity (0- light line, 1- dark line)'''

        self.calibration_param = None
        self.polarity = polarity
        # position of the robot relative to the line ('left', 'right', or 'centered')
        self.state = None
        # init greyscale values
        self.gs_rel_position = 0
        self.gs_val_list = [0,0,0]
        # init camera values
        self.cam_rel_position = 0
        self.cam_val = None

    def line_consumer_producer(self, gs_bus, camera_bus, line_interp_bus, delay):
        """Reads raw data from gs_ and camera_bus, writes interpreted values to 
            line_interp_bus
            Written message: [-1,1] relative numeric position of the robot relative to the line, 
                where 0 is centered and -1 is off the line to the right"""
        # while True:
        self.cam_val = camera_bus.read()
        self.gs_val_list = gs_bus.read()
        self.grayscale_processing()
        line_interp_bus.write(self.gs_rel_position)
        time.sleep(delay)
    
    ####### GRAYSCALE ######
    def calibrate_grayscale(self):
        self.calibration_param = np.mean(self.gs_val_list)
        
    def dark_line(self):

        self.calibrate_grayscale()

        similar_threshold = 0.3
        different_threshold = 0.8
        dark_threshold = 1

        left_val = self.gs_val_list[0]
        middle_val = self.gs_val_list[1]
        right_val = self.gs_val_list[2]

        left_val /= self.calibration_param
        right_val /= self.calibration_param
        middle_val /= self.calibration_param

        # if left and middle have similar readings and are OFF the line (needs to turn hard right)
        if np.isclose(left_val, middle_val, atol=similar_threshold) and (left_val - right_val) > different_threshold:
            self.state = "left"
            self.gs_rel_position = 2/3
        # if right and middle have similar readings and are ON the line (needs to turn slight right)
        elif np.isclose(right_val, middle_val, atol=similar_threshold) and (left_val - right_val) > different_threshold:
            self.state = "left"
            self.gs_rel_position = 1/3
        # if left and middle have similar readings and are ON the line (needs to turn slight left)
        elif np.isclose(left_val, middle_val, atol=similar_threshold) and (right_val - left_val) > different_threshold:
            self.state = "right"
            self.gs_rel_position = -1/3
        # if right and middle have similar readings and are OFF the line (needs to turn hard left)
        elif np.isclose(right_val, middle_val, atol=similar_threshold) and (right_val - left_val) > different_threshold:
            self.state = "right"
            self.gs_rel_position = -2/3
        # if centered and on the line
        elif np.isclose(right_val, left_val, atol=similar_threshold) and right_val < dark_threshold:
            self.state = "middle"
            self.gs_rel_position = 0
        # if centered and off the line
        elif np.isclose(right_val, left_val, atol=similar_threshold) and right_val > dark_threshold:
            self.state = "off"
            self.gs_rel_position = 0
        
    def light_line(self):
        pass
    
    @log_on_end(logging.WARN, "Relative pos to line: {self.gs_rel_position}")
    def grayscale_processing(self, gs_val):
        """Calls functions to set self.state and self.gs_rel_position
            depending on the polarity of the line"""
        if gs_val is not None:
            self.gs_val_list = gs_val
        if self.polarity == 1:
            self.dark_line()
        elif self.polarity == 0:
            self.light_line()
        return self.gs_rel_position

    ####### CAMERA ########
    def camera_processing(self):
        """Operates on self.cam_val, a lane line generated by the camera"""
        x1, y1, x2, y2 = self.cam_val
        # average the x positions of the line? take x1? find an x value
        # map that value to a steering angle based on the slope

if __name__ == "__main__":
    from sensor import Sensor
    snsr = Sensor()
    intr = Interpretor()

    # line following data test
    # gm_val_list = snsr.sense_line()
    # print(gm_val_list)
    # intr.grayscale_processing(gm_val_list)

    snsr.stream_camera()
